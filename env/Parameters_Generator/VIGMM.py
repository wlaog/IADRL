import pandas as pd
import numpy as np
from sklearn.mixture import BayesianGaussianMixture
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from scipy.stats import norm

class myData:
    """
    This class holds the original and standardized data, along with methods for scaling.
    Attributes:
        - data: Original dataset.
        - data_scaled: Standardized data.
    Methods:
        - scaler.inverse_transform(data_scaled): Inverse transformation to get original data from standardized data.
    """
    def __init__(self, data):
        self.data = data
        self.scaler = StandardScaler()
        self.data_scaled = self.scaler.fit_transform(data)


class VIGMMGenerator:
    def __init__(self, n_components=40, covariance_type='full', random_state=None):
        """
        Initialize the VIGMMGenerator class with BayesianGaussianMixture.
        
        Parameters:
        - n_components: Max number of components for the Variational Inference GMM to start with.
        - covariance_type: Type of covariance (e.g., 'full', 'tied', 'diag', 'spherical').
        - random_state: Seed for reproducibility.
        """
        self.n_components = n_components
        self.covariance_type = covariance_type
        self.random_state = random_state
        self.vbgmm = None
        self.scaler = StandardScaler()

    def fit(self, data_array):
        """
        Fit the VBGMM to the provided data.
        
        Parameters:
        - data_array: Standardized data as a NumPy array with shape (samples, dimensions).
        """
        self.vbgmm = BayesianGaussianMixture(
            n_components=self.n_components,
            covariance_type=self.covariance_type,
            random_state=self.random_state,
            weight_concentration_prior_type='dirichlet_process'
        )
        self.vbgmm.fit(data_array)
        print("VIGMM fitting complete with automatic component selection.")

    def generate_samples(self, n_samples=1):
        """
        Generate new samples based on the fitted VIGMM model.
        
        Parameters:
        - n_samples: Number of samples to generate.
        
        Returns:
        - Generated samples as a NumPy array with shape (n_samples, dimensions).
        """
        if self.vbgmm is None:
            raise ValueError("VIGMM model has not been fitted. Please fit the model first.")

        samples, _ = self.vbgmm.sample(n_samples)
        return samples

    def model_info(self):
        """
        Return information about the fitted VIGMM model, including component weights, means, and covariances.
        
        Returns:
        - Dictionary with weights, means, and covariances of active components.
        """
        if self.vbgmm is None:
            raise ValueError("VIGMM model has not been fitted. Please fit the model first.")
        
        return {
            'weights': self.vbgmm.weights_,
            'means': self.vbgmm.means_,
            'covariances': self.vbgmm.covariances_
        }


def plot_vbgmm_comparison(data_array, generated_samples, vbgmm_model=None, dimension_names=None, bins_=20):
    """
    Plot a comparison of original data, generated data, and VIGMM PDF for each dimension.
    
    Parameters:
    - data_array: Standardized original data.
    - generated_samples: Samples generated by VIGMM.
    - vbgmm_model: The fitted BayesianGaussianMixture model.
    - dimension_names: Optional list of names for the dimensions.
    """
    fig, axes = plt.subplots(3, 4, figsize=(18, 12))
    axes = axes.flatten()

    for i in range(data_array.shape[1]):
        # Histogram of original and generated data
        axes[i].hist(data_array[:, i], bins=bins_, density=True, alpha=0.6, color='blue', label='Original Data')
        axes[i].hist(generated_samples[:, i], bins=bins_, density=True, alpha=0.6, color='orange', label='Generated Data')

        if vbgmm_model is not None:
            # GMM PDF curve
            x_vals = np.linspace(data_array[:, i].min(), data_array[:, i].max(), 100)
            pdf_vals = np.zeros_like(x_vals)

            for component in range(vbgmm_model.n_components):
                if vbgmm_model.weights_[component] > 1e-3:  # Filter out negligible components
                    mean = vbgmm_model.means_[component, i]
                    std_dev = np.sqrt(vbgmm_model.covariances_[component][i, i] if vbgmm_model.covariance_type == 'full' else vbgmm_model.covariances_[component])
                    pdf_vals += vbgmm_model.weights_[component] * norm.pdf(x_vals, mean, std_dev)

            # Plot PDF
            axes[i].plot(x_vals, pdf_vals, color='green', linestyle='--', linewidth=2, label='VIGMM PDF')

        axes[i].set_title(dimension_names[i] if dimension_names else f'Dimension {i+1}')
        axes[i].legend()

    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    # Load data
    file_path = 'env/Parameters_Generator/para_all.csv'
    data = pd.read_csv(file_path)
    data_array = myData(data.to_numpy())

    # Initialize and fit VIGMM
    generator = VIGMMGenerator(n_components=40, covariance_type='full')
    generator.fit(data_array.data_scaled)

    # Generate new samples
    generated_samples_scaled = generator.generate_samples(n_samples=2990)

    # Plot comparison
    dimension_names = ["Lambda", "Vp exp", "Tgoal_g", "Shape1", "Shape2", "Shape3", "Shape4", "Tgoal_y", "Tper", "Beta1", "Beta2", "Beta3"]
    plot_vbgmm_comparison(data_array.data_scaled, generated_samples_scaled, generator.vbgmm, dimension_names)
